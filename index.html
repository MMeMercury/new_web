<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>软件工程刷题（5题随机）</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "Segoe UI", sans-serif;
      margin: 0; padding: 0;
      background: #f2f3f5;
      color: #333;
    }
    header {
      background: #4ecdc4;
      color: #fff;
      padding: 16px;
      text-align: center;
      font-size: 1.25rem;
      font-weight: bold;
    }
    main {
      padding: 16px;
    }
    .question {
      background: #fff;
      margin-bottom: 16px;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .question h2 {
      margin: 0 0 8px;
      font-size: 1rem;
      color: #4a4a4a;
    }
    .options label {
      display: block;
      margin-bottom: 8px;
      cursor: pointer;
    }
    .options input {
      margin-right: 8px;
    }
    .btn-submit, .btn-reset {
      display: block;
      width: 100%;
      padding: 12px;
      background: #667eea;
      color: #fff;
      text-align: center;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      margin-top: 8px;
      cursor: pointer;
    }
    .btn-submit:disabled {
      background: #aaa;
    }
    .result {
      text-align: center;
      margin-top: 12px;
      font-size: 1rem;
    }
  </style>
</head>
<body>

<header>软件工程</header>
<main id="quiz">
  <!-- 题目区，JS 动态插入 -->
  <button class="btn-submit" id="submitBtn" disabled>提交答案</button>
  <button class="btn-reset" id="resetBtn">再做一套</button>
  <div class="result" id="result"></div>
</main>

<script>
  // —— 超大题库（这里只示例了前 10 题，后面可自行扩充至上百题）
  const questionBank = [
  {
    "q": " 软件开发瀑布模型中的软件定义时期各个阶段依次是：",
    "opts": [
      "A)   可行性研究，问题定义，需求分析。",
      "B)   问题定义，可行性研究，需求分析。",
      "C)   可行性研究，需求分析，问题定义。",
      "D) 以上顺序都不对。\n"
    ],
    "a": "B"
  },
  {
    "q": " 可行性研究主要从以下几个方面进行研究：",
    "opts": [
      "A)   技术可行性，经济可行性，操作可行性。",
      "B)   技术可行性，经济可行性，系统可行性。",
      "C)   经济可行性，系统可行性，操作可行性。",
      "D)   经济可行性，系统可行性，时间可行性。"
    ],
    "a": "A"
  },
  {
    "q": " 耦合是对软件不同模块之间互连程度的度量 各种耦合按从强到弱排列如下：",
    "opts": [
      "A)   内容耦合，控制耦合，数据耦合，公共环境耦合。",
      "B)   内容耦合，控制耦合，公共环境耦合，数据耦合。",
      "C)   内容耦合，公共环境耦合，控制耦合，数据耦合。 ",
      "D)   控制耦合，内容耦合，数据耦合，公共环境耦合。"
    ],
    "a": "C"
  },
  {
    "q": " 在详细设计阶段所使用到的设计工具是：",
    "opts": [
      "A) 程序流程图，PAD图，N-S图，HIPO图，判定表，判定树.",
      "B) 数据流程图，Yourdon 图，程序流程图，PAD图，N-S图，HIPO图。",
      "C)  判定表，判定树，PDL，程序流程图，PAD图，N-S图。",
      "D)  判定表，判定树，数据流程图，系统流程图，程序流程图，层次图。"
    ],
    "a": "C"
  },
  {
    "q": " 按照软件工程的原则，模块的作用域和模块的控制域之间的关系是：",
    "opts": [
      "A)  模块的作用域应在模块的控制域之内。",
      "B)  模块的控制域应在模块的作用域之内。",
      "C)  模块的控制域与模块的作用域互相独立。",
      "D)  以上说法都不对。"
    ],
    "a": "A"
  },
  {
    "q": " 在软件生命周期中，能准确确定软件系统的体系结构的功能阶段是",
    "opts": [
      "A)  概要设计",
      "B)  详细设计",
      "C)  需求分析",
      "D)  可行性分析"
    ],
    "a": "C"
  },
  {
    "q": " 下面不是软件工程的3个要素的是",
    "opts": [
      "A) 过程",
      "B)  方法",
      "C)  环境",
      "D)  工具\n"
    ],
    "a": "C"
  },
  {
    "q": " 下面不属于软件的组成的是",
    "opts": [
      "A) 程序",
      "B)  记录",
      "C)  文档",
      "D)  数据\n"
    ],
    "a": "B"
  },
  {
    "q": " 在瀑布模型中，将软件分为若干个时期，软件项目的可行性研究一般归属于",
    "opts": [
      "A)  维护时期",
      "B)  运行时期",
      "C)  定义时期",
      "D)  开发时期"
    ],
    "a": "C"
  },
  {
    "q": " 在瀑布模型中，下面()是其突出的缺点 ",
    "opts": [
      "A)  不适应平台的变动",
      "B)  不适应算法的变动",
      "C)  不适应用户需求的变动",
      "D)  不适应程序语言的变动"
    ],
    "a": "C"
  },
  {
    "q": "下面不属于软件的特点的是  ",
    "opts": [
      "A) 软件是一种软件产品",
      "B) 软件产品不会用坏，不存在磨损 消耗问题",
      "C) 软件产品的生产主要是研制",
      "D) 软件产品非常便宜"
    ],
    "a": "D"
  },
  {
    "q": "软件开发工具是协助开发人员进行软件开发活动所使用的软件或环境 下面不是软件开发工具的是 ",
    "opts": [
      "A)  维护工具",
      "B)  编码工具",
      "C)  测试工具",
      "D)  需求分析工具"
    ],
    "a": "A"
  },
  {
    "q": " 下列叙述中不属于软件生命周期模型的是  ",
    "opts": [
      "A)  原型模型",
      "B)  瀑布模型",
      "C)  螺旋模型",
      "D)  快速组装模型"
    ],
    "a": "D"
  },
  {
    "q": " 软件设计中，用抽象和分解的目的是  ",
    "opts": [
      "A)  提高易读性",
      "B)  降低复杂性",
      "C)  增加内聚性",
      "D)  降低耦合性"
    ],
    "a": "B"
  },
  {
    "q": "软件生命周期中所花费用最多的阶段是  ",
    "opts": [
      "A)  详细设计",
      "B)  软件编码",
      "C)  概要设计",
      "D)  软件测试和维护"
    ],
    "a": "D"
  },
  {
    "q": " 开发软件时对提高开发人员工作效率至关重要的是  ",
    "opts": [
      "A)  操作系统的资源管理功能",
      "B)  先进的软件开发工具和环境",
      "C)  程序人员的数量",
      "D)  计算机的并行处理能力"
    ],
    "a": "B"
  },
  {
    "q": " 开发软件所需高成本和产品的低质量之间有着尖锐的矛盾，这种现象称作  ",
    "opts": [
      "A)  软件投机",
      "B)  软件危机",
      "C)  软件工程",
      "D) 软件产生"
    ],
    "a": "B"
  },
  {
    "q": "软件开发的结构化生命周期方法将软件生命周期划分成",
    "opts": [
      "A)  定义 开发 运行维护",
      "B)  设计阶段 编程阶段 测试阶段",
      "C)  总体设计 详细设计 编程调试",
      "D)  需求分析 功能定义 系统设计"
    ],
    "a": "A"
  },
  {
    "q": " 软件工程的理论和技术性研究的内容主要包括软件开发技术和  ",
    "opts": [
      "A)  消除软件危机",
      "B)  软件工程管理",
      "C)  程序设计自动化",
      "D)  实现软件可重用"
    ],
    "a": "B"
  },
  {
    "q": "软件工程的出现是由于  ",
    "opts": [
      "A)  程序设计方法学的影响",
      "B)  软件产业化的需要",
      "C)  软件危机的出现",
      "D)  计算机的发展"
    ],
    "a": "C"
  },
  {
    "q": " 在软件生命周期中，能准确地确定软件系统必须做什么和必须具备哪些功能的阶段是  ",
    "opts": [
      "A)  概要设计",
      "B)  详细设计",
      "C)  问题定义",
      "D)  需求分析"
    ],
    "a": "D"
  },
  {
    "q": " 开发大型软件时，产生困难的根本原因是  ",
    "opts": [
      "A)  大系统的复杂性",
      "B)  人员知识不足",
      "C)  客观世界千变万化",
      "D)  时间紧 任务重"
    ],
    "a": "A"
  },
  {
    "q": " 文档是软件开发人员 软件管理人员 维护人员 用户以及计算机之间的 ，软件开发人员在各个阶段以文档作为前段工作成果的体现和后段工作的基础 ",
    "opts": [
      "A)  接口",
      "B)  桥梁",
      "C)  科学",
      "D)  继续"
    ],
    "a": "B"
  },
  {
    "q": "软件工程学的目的是以 较低的成本，研制 质量的软件 ",
    "opts": [
      "A) 较高",
      "B) 较低",
      "C)  可靠",
      "D)  优秀"
    ],
    "a": "A"
  },
  {
    "q": "软件从一个计算机系统或环境转换到另一个计算机和环境的容易程度称为  ",
    "opts": [
      "A)  可用性",
      "B)  兼容性",
      "C)  可靠性",
      "D)  可移植性"
    ],
    "a": "D"
  },
  {
    "q": " 软件生存周期是指 阶段 ",
    "opts": [
      "A)  软件开始使用到用户要求修改为止",
      "B)  软件开始使用到被淘汰为止",
      "C)  从开始编写程序到不能再使用为止",
      "D)  从立项制定计划，进行需求分析到不能再使用为止"
    ],
    "a": "D"
  },
  {
    "q": " 软件工程学是应用科学理论和工程上的技术指导软件开发的学科，其目的是  ",
    "opts": [
      "A) 引入新技术提高空间利用率",
      "B) 用较少的投资获得高质量的软件",
      "C) 缩短研制周期扩大软件功能",
      "D) 硬软件结合使系统面向应用"
    ],
    "a": "B"
  },
  {
    "q": " 软件可行性分析是着重确定系统的目标和规模 对成本-效益进行发现应属于下列选项中的  ",
    "opts": [
      "A)  经济可行性",
      "B)  操作可行性",
      "C)  技术可行性",
      "D)  社会可行性"
    ],
    "a": "A"
  },
  {
    "q": "在数据流图中，用圆或者椭圆来表示  ",
    "opts": [
      "A)  数据流",
      "B)  加工",
      "C)  数据存储",
      "D)  数据源点或终点"
    ],
    "a": "B"
  },
  {
    "q": " 需求分析阶段的任务是确定  ",
    "opts": [
      "A)  软件开发方法",
      "B)  软件开发费用",
      "C)  软件系统功能",
      "D)  软件开发工具"
    ],
    "a": "C"
  },
  {
    "q": "的目的就是用最小的代价在尽可能短的时间内确定该软件项目是否能够开发，是否值得去开发 ",
    "opts": [
      "A) 需求分析",
      "B) 概要设计",
      "C) 总体设计",
      "D) 可行性研究"
    ],
    "a": "D"
  },
  {
    "q": " 下列选项中 不是软件需求规格目标 ",
    "opts": [
      "A)  便于用户 分析员和软件设计人员进行理解及交流",
      "B)  控制系统的实施过程",
      "C)  作为软件测试和验收以及维护的依据",
      "D)  便于软件的维护"
    ],
    "a": "D"
  },
  {
    "q": "下面描述中，不符合结构化程序设计风格的是  ",
    "opts": [
      "A) 使用顺序 选择和重复 循环 三种基本控制结构表示程序的控制逻辑",
      "B) 模块只有一个入口，可以有多个出口",
      "C) 注重提高程序的执行效率",
      "D) 不使用goto语句"
    ],
    "a": "B"
  },
  {
    "q": " 下列工具中属于需求分析常用工具的是  ",
    "opts": [
      "A) PAD",
      "B) PFD",
      "C)  N-S",
      "D) DFD"
    ],
    "a": "D"
  },
  {
    "q": " 在数据流图中，带有名字的箭头表示  ",
    "opts": [
      "A)  控制程序的执行顺序",
      "B)  模块之间的调用关系",
      "C)  数据的流向",
      "D)  程序的组成成分\n"
    ],
    "a": "D"
  },
  {
    "q": " 在软件生产过程中，需求信息的给出是  ",
    "opts": [
      "A)  程序员",
      "B)  项目管理者",
      "C)  软件分析设计人员",
      "D)  软件用户"
    ],
    "a": "D"
  },
  {
    "q": "下列叙述中，不属于结构化分析方法的是  ",
    "opts": [
      "A)  面向数据流的结构化分析方法",
      "B)  面向数据结构的结构化数据系统开发方法",
      "C)  面向对象的分析方法",
      "D) 以上都不对"
    ],
    "a": "C"
  },
  {
    "q": "结构设计SD是一种应用最广泛的系统设计方法，是以 为基础 自顶向下 逐步求精和模块化的过程 ",
    "opts": [
      "A)  数据流",
      "B)  数据流图",
      "C)  数据库",
      "D) 数据结构"
    ],
    "a": "D"
  },
  {
    "q": "需求分析是由分析员经了解用户的要求，认真细致地调研 分析，最终应建立目标系统的逻辑模型并写出  ",
    "opts": [
      "A)  模块说明书",
      "B)  软件规格说明书",
      "C)  项目开发计划",
      "D)  合同文档"
    ],
    "a": "B"
  },
  {
    "q": " 结构化分析方法以数据流图()和加工说明等描述工具，即用直观的图和简洁的语言来描述软件系统模型 ",
    "opts": [
      "A) DFD图",
      "B)  PAD图",
      "C)  IPO图",
      "D)  数据字典"
    ],
    "a": "D"
  },
  {
    "q": " 数据字典是软件需求分析阶段的重要工具之一，它的基本功能是",
    "opts": [
      "A)  数据定义",
      "B)  数据维护",
      "C)  数据通讯",
      "D)  数据库设计"
    ],
    "a": "A"
  },
  {
    "q": " 以下()不是详细设计中常用的图形描述工具 ",
    "opts": [
      "A) 数据流图",
      "B)  程序流图",
      "C)  盒图 N-S ",
      "D)  问题分析图(PAD)"
    ],
    "a": "A"
  },
  {
    "q": " 在结构图的有关术语中，用于表示软件结构中控制的层数的是",
    "opts": [
      "A)  扇入",
      "B) 扇出",
      "C) 深度",
      "D) 宽度"
    ],
    "a": "C"
  },
  {
    "q": " 模块的独立程度是评价设计好坏的重要标准 ()是衡量软件的模块独立性的两个定性度量标准",
    "opts": [
      "A) 耦合性和内聚性",
      "B) 内聚性和可靠性",
      "C) 耦合性和独立性",
      "D) 可靠性和独立性"
    ],
    "a": "A"
  },
  {
    "q": " 软件设计包括()两个阶段 ",
    "opts": [
      "A)  接口设计和结构设计",
      "B)  概要设计和详细设计",
      "C)  数据设计和概要设计",
      "D)  结构设计和过程设计"
    ],
    "a": "B"
  },
  {
    "q": "在详细设计阶段，经常采用的工具是  ",
    "opts": [
      "A) PAD",
      "B) SA",
      "C)  SC(结构图，总体设计) ",
      "D) DFD"
    ],
    "a": "A"
  },
  {
    "q": " 在软件开发中，下面任务不属于设计阶段的是  ",
    "opts": [
      "A)  数据结构设计",
      "B) 给出系统模块结构",
      "C) 定义模块算法",
      "D) 定义需求并建立系统模型"
    ],
    "a": "D"
  },
  {
    "q": " 对建立良好的程序设计风格，下面描述正确的是  ",
    "opts": [
      "A) 程序应简单 清晰 可读性好",
      "B) 符号名的命名要符合语法",
      "C) 充分考虑程序的执行效率",
      "D) 程序的注释可有可无"
    ],
    "a": "A"
  },
  {
    "q": " 下面不属于软件设计原则的是  ",
    "opts": [
      "A) 抽象",
      "B) 模块化",
      "C) 自底向上",
      "D) 信息隐蔽"
    ],
    "a": "C"
  },
  {
    "q": " 为了避免流程图在描述程序逻辑时的灵活性，提出了用方框图来代替传统的程序流程图，通常也把这种图称为  ",
    "opts": [
      "A) PAD图",
      "B)  N-S图",
      "C)  结构图",
      "D) 数据流图"
    ],
    "a": "C"
  },
  {
    "q": "软件测试按照功能划分可以分为  ",
    "opts": [
      "A) 黑盒测试和单元测试",
      "B) 白盒测试和黑盒测试",
      "C) 集成测试和单元测试",
      "D) 白盒测试和静态测试\n"
    ],
    "a": "B"
  },
  {
    "q": "在软件测试过程的4个步骤中，测试依据是需求规格说明的是",
    "opts": [
      "A) 单元测试",
      "B) 集成测试",
      "C) 确认测试",
      "D) 系统测试"
    ],
    "a": "C"
  },
  {
    "q": "黑盒测试法属于  ",
    "opts": [
      "A) 集成测试",
      "B) 系统测试",
      "C) 动态测试",
      "D) 静态测试"
    ],
    "a": "C"
  },
  {
    "q": "下列叙述中错误的是  ",
    "opts": [
      "A) 测试是为了寻找错误而运行程序的过程",
      "B) 一个成功的测试是揭示了迄今为止尚未发现的错误的测试",
      "C) 测试的目的是为了证明程序是正确的",
      "D) 一个好的测试用例是指很可能找到迄今为止尚未发现的错误的测试"
    ],
    "a": "C"
  },
  {
    "q": "软件测试过程是软件开发过程的逆过程，其最基础性的测试应是",
    "opts": [
      "A) 集成测试",
      "B) 单元测试",
      "C) 有效性测试",
      "D) 系统测试"
    ],
    "a": "C"
  },
  {
    "q": "有一组测试用例使得每一个被测试用例的分支覆盖至少被执行一次，它满足的覆盖标准___________ ",
    "opts": [
      "A)   语句覆盖",
      "B)  判定覆盖",
      "C)  条件覆盖",
      "D)  路径覆盖"
    ],
    "a": "B"
  },
  {
    "q": " 关于白盒测试与黑盒测试的最主要区别，正确的是__ ",
    "opts": [
      "A)  \n白盒测试侧重于程序结构，黑盒测试侧重于功能",
      "B) 白盒测试可以使用测试工具，黑盒测试不能使用工具",
      "C) 白盒测试需要程序参与，黑盒测试不需要",
      "D) 黑盒测试比白盒测试应用更广泛"
    ],
    "a": "A"
  },
  {
    "q": " 程序的三种基本控制结构是  ",
    "opts": [
      "A)   过程 子程序和分程序",
      "B)   顺序 选择和重复",
      "C)   递归 迭代和回溯",
      "D)   调用 返回和转移"
    ],
    "a": "B"
  },
  {
    "q": " 面向对象的分析方法主要是建立三类模型，即  ",
    "opts": [
      "A)   系统模型 ER模型 应用模型",
      "B)   对象模型 动态模型 应用模型",
      "C)   Ｅ-Ｒ模型 对象模型 功能模型",
      "D)   对象模型 动态模型 功能模型"
    ],
    "a": "D"
  },
  {
    "q": " 软件测试的目标是  ",
    "opts": [
      "A)   证明软件是正确的",
      "B)   发现错误 降低错误带来的风险",
      "C)   排除软件中所有的错误",
      "D)   与软件调试相同"
    ],
    "a": "B"
  },
  {
    "q": " 软件生命周期中所花费用最多的阶段是",
    "opts": [
      "A)  详细设计",
      "B)  软件编码",
      "C)  软件测试",
      "D)  软件维护"
    ],
    "a": "D"
  },
  {
    "q": " 在数据流图中, 圆或椭圆表示 1 ，平行线表示 2 __ ",
    "opts": [
      "A)  加工",
      "B)  外部实体",
      "C)  数据流 箭头 ",
      "D)  存储"
    ],
    "a": "A"
  },
  {
    "q": " 瀑布模型 突出的缺点是不适应 的变动 ",
    "opts": [
      "A)  算法",
      "B)  平台",
      "C)  程序语言",
      "D)  用户需求"
    ],
    "a": "D"
  },
  {
    "q": " 结构化分析方法的一个重要指导思想是  ",
    "opts": [
      "A)  自顶向下，逐步抽象",
      "B)  自底向上，逐步抽象",
      "C)  自顶向下，逐步分解",
      "D)  自底向上，逐步分解"
    ],
    "a": "A"
  },
  {
    "q": " 模块的控制范围包括它本身及它所有的从属模块，模块的作用范围是指模块内一个判定的作用范围，凡是受到这个判定影响的所有模块都属于这个判定的作用范围，理想的情况是",
    "opts": [
      "A)  模块的作用范围应在控制范围之内",
      "B)  模块的控制范围应在作用范围之内",
      "C)  模块的作用范围与控制范围交叉",
      "D)   模块的作用范围与控制范围不相交"
    ],
    "a": "A"
  },
  {
    "q": " 软件危机具有下列表现 I、对软件开发成本估计不准确 II、软件产品的质量往往不可靠 III、软件常常不可维护 IV、软件成本逐年上升",
    "opts": [
      "A)  I II和III",
      "B)  I III和IV",
      "C)  II III和IV",
      "D)  以上都正确"
    ],
    "a": "D"
  },
  {
    "q": " 产生软件危机的原因可能有 ）I、用户需求描述不精确、不准确 II、对大型软件项目的开发缺乏有力的组织与管理 III、缺乏有力的方法学和工具的支持 IV、软件产品的特殊性和人类智力的局限性",
    "opts": [
      "A)  I和II",
      "B)  I II和IV",
      "C)  II III和IV",
      "D)  以上都正确"
    ],
    "a": "D"
  },
  {
    "q": " 分批地逐步向用户提交产品，每次提交一个满足用户需求子集的可运行的产品 ",
    "opts": [
      "A)  增量模型  分批 ",
      "B)  喷泉模型 重叠 ",
      "C)  原型模型",
      "D)  螺旋模型 迭代，风险分析 "
    ],
    "a": "A"
  },
  {
    "q": " 为了克服软件危机，人们提出了用 的原理来设计软件，这就是软件工程诞生的基础 ",
    "opts": [
      "A)   数学",
      "B)   软件学",
      "C)   运筹学",
      "D)   工程学"
    ],
    "a": "D"
  },
  {
    "q": " 具有风险分析的软件生存周期模型是",
    "opts": [
      "A)  瀑布模型",
      "B)  喷泉模型",
      "C)  螺旋模型",
      "D)  增量模型"
    ],
    "a": "C"
  },
  {
    "q": " 瀑布模型的关键不足在于",
    "opts": [
      "A)  过于简单",
      "B)  不能适应需求的动态变更",
      "C) 过于灵活",
      "D) 各个阶段需要进行评审"
    ],
    "a": "B"
  },
  {
    "q": " 软件工程的目标有  ",
    "opts": [
      "A)  易于维护",
      "B)  低的开发成本",
      "C)  高性能",
      "D)  短的开发期"
    ],
    "a": "B"
  },
  {
    "q": " 软件工程学的目的和意义是  ",
    "opts": [
      "A)  应用科学的方法和工程化的规范管理来指导软件开发",
      "B)  克服软件危机",
      "C)  做好软件开发的培训工作",
      "D)  以较低的成本开发出高质量的软件"
    ],
    "a": "D"
  },
  {
    "q": " 开发软件所需高成本和产品的低质量之间有着尖锐的矛盾，这种现象称做",
    "opts": [
      "A)   软件工程",
      "B)   软件周期",
      "C)   软件危机",
      "D)   软件产生"
    ],
    "a": "C"
  },
  {
    "q": " 快速原型模型的主要特点之一是",
    "opts": [
      "A)   开发完毕才见到产品",
      "B)   及早提供全部完整的软件产品",
      "C)   开发完毕后才见到工作软件",
      "D)   及早提供工作软件"
    ],
    "a": "D"
  },
  {
    "q": " 瀑布模型的存在问题是",
    "opts": [
      "A)  用户容易参与开发",
      "B)  缺乏灵活性",
      "C)  用户与开发者易沟通",
      "D)  适用可变需求"
    ],
    "a": "B"
  },
  {
    "q": " 软件生存周期模型不包括：",
    "opts": [
      "A)  瀑布模型",
      "B)  对象模型",
      "C)  增量模型",
      "D)  喷泉模型"
    ],
    "a": "B"
  },
  {
    "q": " 下列哪个不属于软件工程的内涵之一",
    "opts": [
      "A)  应用完善的科学与工程原理",
      "B)  经济地开发软件",
      "C)  高薪聘请软件高手",
      "D)  开发既可靠又能有效运行的软件"
    ],
    "a": "C"
  },
  {
    "q": " 在瀑布模型中，将软件划分为若干个时期，软件项目的可行性研究一般归属于  ",
    "opts": [
      "A)  维护时期",
      "B)  计划时期",
      "C)  运行时期",
      "D)  开发时期"
    ],
    "a": "B"
  },
  {
    "q": " 下列哪个办法不属于解决软件危机的途径之一",
    "opts": [
      "A)   研制新一代智能计算机",
      "B)   大力扶持软件企业",
      "C)   采用软件工程的解决途径",
      "D)   采用面向对象的软件设计方法"
    ],
    "a": "B"
  },
  {
    "q": " 下面哪一项不属于快速原型模型的优点 ",
    "opts": [
      "A)  可及早为用户提供有用的产品。",
      "B)  可保证在开发后期，全面发现错误给以纠正。",
      "C)  减少技术应用风险，缩短开发时间，减少费用 提高生产率。",
      "D)  促使用户主动参与开发活动，促进各类人员的协调，适应需求变化。"
    ],
    "a": "B"
  },
  {
    "q": " 下列哪个不属于瀑布模型与传统的程序设计的不同之处  ",
    "opts": [
      "A)  传统的程序设计开发人员只开发程序,不写文档 ",
      "B)  传统的程序设计重点在问题求解和算法,并只有自己才能读懂 ",
      "C)  瀑布模型的各阶段要第三方介入审察",
      "D)  传统的程序设计规定各阶段必须写文档 "
    ],
    "a": "D"
  },
  {
    "q": " 下面哪个模式不属于软件工程的开发模式",
    "opts": [
      "A)  基于瀑布模型的开发模式",
      "B)  基于原型模型的开发模式",
      "C)  基于人机对话的开发模式",
      "D)  基于关系数据库的开发模式"
    ],
    "a": "C"
  },
  {
    "q": " 数据字典是数据流图中所有元素的定义的集合，一般由以下四类条目组成  ",
    "opts": [
      "A)  数据说明条目 控制流条目 加工条目 数据存储条目",
      "B)  数据流条目 数据项条目 数据存储条目 加工条目",
      "C)  数据源条目 数据流条目 数据处理条目 数据文件条目",
      "D)  数据流条目 数据文件条目 数据项条目 加工条目"
    ],
    "a": "B"
  },
  {
    "q": " 下列模型属于成本估算方法的有",
    "opts": [
      "A) COCOMO 模型",
      "B) McCall 模型",
      "C) McCabe 度量法",
      "D)   时间估算法"
    ],
    "a": "A"
  },
  {
    "q": " 图反映系统",
    "opts": [
      "A)  怎么做",
      "B)  对谁做",
      "C)  何时做",
      "D)  做什么"
    ],
    "a": "D"
  },
  {
    "q": " 经济可行性研究的范围包括",
    "opts": [
      "A)  资源有效性",
      "B)  管理制度",
      "C)  效益分析",
      "D)  开发风险"
    ],
    "a": "C"
  },
  {
    "q": " 为高质量地开发软件项目，在软件结构设计时，必须遵循()原则 ",
    "opts": [
      "A)  信息隐蔽",
      "B)  质量控制",
      "C)  程序优化",
      "D)  数据共享"
    ],
    "a": "A"
  },
  {
    "q": " 需求规格说明书的作用不包括",
    "opts": [
      "A)  软件验收的依据",
      "B)  用户与开发人员对软件要做什么的共同理解",
      "C)  软件可行性研究的依据",
      "D)  软件设计的依据"
    ],
    "a": "C"
  },
  {
    "q": " 分层数据流图是一种比较严格又易于理解的描述方式，它的顶层描述了系统的  ",
    "opts": [
      "A)  总貌",
      "B)  细节",
      "C)  抽象",
      "D)  软件的作者"
    ],
    "a": "A"
  },
  {
    "q": " 经调查，系统分析员给出有问题的初略陈述，其中部分描述如下：某商场的采购部门要求每天开出定购清单，交采购员；仓库管理员将此要还应输入系统，经库存业务进贷或出贷处理后输出 从这段描述可知该部分数据流图中的外部项为：",
    "opts": [
      "A)  采购员 仓库管理员",
      "B)  定购清单 库存业务",
      "C)  库存业务",
      "D)  定购清单 采购员"
    ],
    "a": "A"
  },
  {
    "q": " 数据流是数据流图的基本成分，下列关于数据流的叙述中， 是正确的 ",
    "opts": [
      "A)  某加工的输入是一个数据流，该加工的输出也必定是一个数据流",
      "B)  多个不同的数据流可以流向一个加工，也可从一个加工中流出",
      "C)  数据流只能从加工流向文件，但不能从文件流向加工",
      "D)  一个数据流可以从一个文件流向另一个文件"
    ],
    "a": "B"
  },
  {
    "q": " 需求分析阶段最重要的技术文档之一是：",
    "opts": [
      "A)  项目开发计划",
      "B)  设计说明书",
      "C)  需求规格说明书",
      "D)  可行性分析报告"
    ],
    "a": "C"
  },
  {
    "q": " 需求工程的主要目的是",
    "opts": [
      "A)  系统开发的具体方案",
      "B)   进一步确定用户的需求",
      "C)  解决系统是“做什么的问题”",
      "D)   解决系统是“如何做的问题”"
    ],
    "a": "C"
  },
  {
    "q": " 不适于作为数据流图处理加工框名称的是____ ",
    "opts": [
      "A)  人工校核工资数据",
      "B)  工资支票数据",
      "C)  打印工资支票",
      "D)  计算职工工资"
    ],
    "a": "B"
  },
  {
    "q": "结构化程序设计思想的核心是要求程序只由顺序 循环和 三种结构组成 ",
    "opts": [
      "A)   选择",
      "B)   单入口",
      "C)   单出口",
      "D)   有规则 GOTO"
    ],
    "a": "A"
  },
  {
    "q": " 模块()，则说明模块的独立性越强 ",
    "opts": [
      "A)   耦合越强",
      "B)   扇入数越高",
      "C)   耦合越弱",
      "D)   扇入数越低"
    ],
    "a": "C"
  },
  {
    "q": " 当一个模块直接使用另一个模块的内部数据，这种模块之间的耦合为",
    "opts": [
      "A)  数据耦合",
      "B)  公共耦合",
      "C)  标记耦合",
      "D)  内容耦合\n"
    ],
    "a": "D"
  },
  {
    "q": " 软件结构图中，模块框之间若有直线连接，表示它们之间存在",
    "opts": [
      "A)  调用关系",
      "B)  组成关系",
      "C)  链接关系",
      "D)  顺序执行关系"
    ],
    "a": "A"
  },
  {
    "q": " 概要设计最终结果是产生",
    "opts": [
      "A)  项目开发计划",
      "B)  需求规格说明书",
      "C)  软件结构设计说明书",
      "D)  可行性分析报告"
    ],
    "a": "C"
  },
  {
    "q": " 在有集成组装测试的叙述中，__ 是正确的 ",
    "opts": [
      "A) 测试底层模块时不需要桩模块",
      "B) 驱动模块的作用是模拟被调模块",
      "C) 自顶向下测试方法易于设计测试结果",
      "D) 自底向上测试方法有有利于提前预计测试结果"
    ],
    "a": "A"
  },
  {
    "q": " 程序功能说明中指出：由三个输入数据表示一个三角形的三条边长 根据黑盒法中的边缘值分析法设计测试用例，应选_____ ",
    "opts": [
      "A) a=1,b=2,c=4",
      "B)  a=1,b=2,c=3",
      "C) a=3,b=4,c=5",
      "D) 上述A.B 项目都应选上"
    ],
    "a": "D"
  },
  {
    "q": " 软件维护的副作用，是指  ",
    "opts": [
      "A)  开发时的错误",
      "B)  隐含的错误",
      "C)  因修改软件而造成的错误",
      "D)  运行时误操作"
    ],
    "a": "C"
  },
  {
    "q": " 在考察系统的一些涉及时序和改变的状态时，要用动态模型来表示 动态模型着重于系统的控制逻辑，它包括两个图：一个是事件追踪图，另一个是  ",
    "opts": [
      "A)  状态图",
      "B)  数据流图",
      "C)  系统结构图",
      "D)  时序图"
    ],
    "a": "D"
  },
  {
    "q": " 面向对象分析是对系统进行 的一种方法 ",
    "opts": [
      "A)  需求建模",
      "B)  程序设计",
      "C)  设计评审",
      "D)  测试验收"
    ],
    "a": "A"
  },
  {
    "q": "()是把对象的属性和操作结合在一起，构成一个独立的对象，其内部信息对外界是隐蔽的，外界只能通过有限的接口与对象发生联系 ",
    "opts": [
      "A)  多态性",
      "B)  继承",
      "C)  封装",
      "D)  消息"
    ],
    "a": "C"
  },
  {
    "q": " 下列不属于面向对象开发方法的是",
    "opts": [
      "A) Booch",
      "B)  UML",
      "C) Coad",
      "D)  OMT"
    ],
    "a": "B"
  },
  {
    "q": " 面向对象的分析方法主要是建立三类模型，即",
    "opts": [
      "A)  系统模型，ER模型，应用模型",
      "B)  对象模型，动态模型，实现 应用 模型",
      "C)  ER模型，对象模型，功能模型",
      "D)  对象模型，动态模型，功能模型"
    ],
    "a": "D"
  },
  {
    "q": " 面向对象程序设计的基本机制",
    "opts": [
      "A)  继承",
      "B)  消息",
      "C)  方法",
      "D)  结构"
    ],
    "a": "A"
  },
  {
    "q": " 下列属于面向对象的要素有",
    "opts": [
      "A)  分类性",
      "B)  抽象",
      "C)  对象",
      "D)  封装\n对象三要素：对象 属性 服务"
    ],
    "a": "C"
  },
  {
    "q": " 在进行面向对象分析时，所采用的模型有()",
    "opts": [
      "A)  对象模型",
      "B)  动态模型",
      "C)  静态模型",
      "D)  功能模型"
    ],
    "a": "C"
  },
  {
    "q": " 状态是对象属性的值的一种抽象，它的性质有   。",
    "opts": [
      "A)  时间性",
      "B)  持续性",
      "C)  有序性",
      "D)  有穷性"
    ],
    "a": "C"
  },
  {
    "q": " 建立继承关系时所采用的方式有()",
    "opts": [
      "A)  自顶向下",
      "B)  从内到外",
      "C)  自底向上",
      "D)  从复杂到简单"
    ],
    "a": "C"
  },
  {
    "q": " 对象是人们要研究的任何事物，主要的对象类型有()",
    "opts": [
      "A)  有形实体",
      "B)  作用",
      "C)  事件",
      "D)  性能说明"
    ],
    "a": "C"
  },
  {
    "q": " 类库这种机制是()级别的信息共享 ",
    "opts": [
      "A)   同一类",
      "B)   不同类",
      "C)   同一应用",
      "D)   不同应用"
    ],
    "a": "D"
  },
  {
    "q": " 状态是对象()的抽象 ",
    "opts": [
      "A) 属性值",
      "B)   方法",
      "C)   功能",
      "D)   行为"
    ],
    "a": "D"
  },
  {
    "q": " 动态模型的描述工具是  ",
    "opts": [
      "A)   对象图",
      "B)   结构图",
      "C)   流程图",
      "D)   状态图"
    ],
    "a": "D"
  },
  {
    "q": " 在确定对象的属性中，所有 是候选的对象 ",
    "opts": [
      "A)   名词",
      "B)   动词",
      "C)   词组",
      "D)   修饰性名词词组"
    ],
    "a": "A"
  },
  {
    "q": " 对象实现了数据和操作的结合，使数据和操作 于对象的统一体中 ",
    "opts": [
      "A)  结合",
      "B)  隐藏",
      "C)  封装",
      "D)  抽象"
    ],
    "a": "C"
  },
  {
    "q": " OOA是",
    "opts": [
      "A)   结构化分析",
      "B)  面向对象程序设计",
      "C)   面向对象程序分析",
      "D)   面向对象分析"
    ],
    "a": "A"
  },
  {
    "q": " 面向对象的特征不包括",
    "opts": [
      "A)  继承性。",
      "B)  多态性。",
      "C)  互换性",
      "D)    封装性"
    ],
    "a": "C"
  },
  {
    "q": " 在面向对象软件开发方法中，类与类之间主要有以下结构关系",
    "opts": [
      "A) 继承和聚集",
      "B) 继承和一般",
      "C) 聚集和消息传递",
      "D) 继承和方法调用"
    ],
    "a": "D"
  },
  {
    "q": " 以下哪一项不是面向对象的特征",
    "opts": [
      "A) 多态性",
      "B) 继承性",
      "C) 封装性",
      "D) 过程调用"
    ],
    "a": "D"
  },
  {
    "q": " 对象实现了数据和操作的结合，使数据和操作 于对象的统一体中 ",
    "opts": [
      "A)  结合",
      "B)  隐藏",
      "C)  封装",
      "D)  抽象"
    ],
    "a": "C"
  },
  {
    "q": " 在面向对象软件开发方法中，类与类之间主要有以下结构关系",
    "opts": [
      "A) 继承和聚集",
      "B) 继承和一般",
      "C) 聚集和消息传递",
      "D) 继承和方法调用"
    ],
    "a": "A"
  },
  {
    "q": " 以下哪一项不是面向对象的特征",
    "opts": [
      "A) 多态性",
      "B) 继承性",
      "C) 封装性",
      "D) 过程调用"
    ],
    "a": "D"
  },
  {
    "q": " 下面所列的性质中， 不属于面向对象程序设计的特性 ",
    "opts": [
      "A)  继承性",
      "B)  重用性",
      "C)  封装性",
      "D)  可视化"
    ],
    "a": "D"
  },
  {
    "q": " 下列是面向对象设计方法中有关对象的叙述，其中 是正确的 ",
    "opts": [
      "A)  对象在内存中没有它的存储区",
      "B)  对象的属性集合是它的特征表示",
      "C)  对象的定义与程序中类型概念相当",
      "D)  对象之间不能相互通信"
    ],
    "a": "B"
  },
  {
    "q": " 在面向对象软件方法中，“类”是  ",
    "opts": [
      "A)  具有同类数据的对象的集合",
      "B)  具有相同操作的对象的集合",
      "C)  具有同类数据的对象的定义",
      "D)  具有同类数据和相同操作的对象的定义"
    ],
    "a": "D"
  },
  {
    "q": " 面向对象分析时，所标识的对象为______是错误的 ",
    "opts": [
      "A)  与目标系统有关的物理实体",
      "B)  与目标系统发生作用和人或组织的角色",
      "C)  目标系统运行中需记忆的事件",
      "D)  目标系统中环境场所的状态"
    ],
    "a": "D"
  },
  {
    "q": " 面向对象设计模型的主要部件中，通常不包括_____ ",
    "opts": [
      "A) 通信部件",
      "B)  人机交互部件",
      "C)  任务管理",
      "D)  数据管理"
    ],
    "a": "D"
  },
  {
    "q": " 面向对象设计时，对象信息的隐藏主要是通过______实现的 ",
    "opts": [
      "A)  对象的封装性",
      "B)  子类的继承性",
      "C)  系统模块化",
      "D)  模块的可重用"
    ],
    "a": "A"
  },
  {
    "q": " 作为面向对象分析的基础 由问题领域中的对象所组成 用图来描述是____ ",
    "opts": [
      "A)  消息模型",
      "B)  处理模型",
      "C)  状态模型",
      "D)  瀑布模块"
    ],
    "a": "A"
  },
  {
    "q": " 开发软件所需高成本和产品的低质量之间有着尖锐的矛盾，这种现象称作  ",
    "opts": [
      "A)  软件工程",
      "B)  软件周期",
      "C)  软件危机",
      "D)  软件产生"
    ],
    "a": "C"
  },
  {
    "q": " 下面不属于软件工程3要素的是",
    "opts": [
      "A)  工具",
      "B)  过程",
      "C)  方法",
      "D)  环境"
    ],
    "a": "D"
  },
  {
    "q": " 检查软件产品是否符合需求定义的过程称为",
    "opts": [
      "A)  确认测试",
      "B)  集成测试",
      "C)  验证测试",
      "D)  验收测试"
    ],
    "a": "A"
  },
  {
    "q": " 数据存储和数据流都是 ，仅仅是所处的状态不同 ",
    "opts": [
      "A)  分析结果",
      "B)  事件",
      "C)  动作",
      "D)  数据"
    ],
    "a": "D"
  },
  {
    "q": " 数据流图和 共同组成目标系统的逻辑功能模型 ",
    "opts": [
      "A)  HIPO图",
      "B) PDL",
      "C)  数据字典",
      "D)  层次图"
    ],
    "a": "C"
  },
  {
    "q": " 数据流图用于抽象描述一个软件的逻辑模型，数据流图由一些特定的图符构成 下列图符名标识的图符不属于数据流图合法图符的是  ",
    "opts": [
      "A)  控制流",
      "B)  加工",
      "C)  数据存储",
      "D)  源和汇"
    ],
    "a": "A"
  },
  {
    "q": " 结构化分析方法就是面向 的自顶向下逐步求精进行需求分析的方法 ",
    "opts": [
      "A)  目标",
      "B)  数据流",
      "C)  功能",
      "D)  对象"
    ],
    "a": "B"
  },
  {
    "q": " 下面不属于软件工程设计基本原理的是",
    "opts": [
      "A)  抽象",
      "B)  模块化",
      "C)  自底向上",
      "D)  信息隐蔽"
    ],
    "a": "C"
  },
  {
    "q": " 是数据说明 可执行语句等程序对象的集合，它是单独命名的而且可以通过名字来访问 ",
    "opts": [
      "A)  模块化",
      "B)  抽象",
      "C)  精化",
      "D)  模块"
    ],
    "a": "D"
  },
  {
    "q": " 面向数据流的设计方法把 映射成软件结构 ",
    "opts": [
      "A)  数据流",
      "B)  系统结构",
      "C)  控制结构",
      "D)  信息流"
    ],
    "a": "D"
  },
  {
    "q": " 程序流程图中的箭头代表的是  ",
    "opts": [
      "A)  数据流",
      "B)  控制流",
      "C)  调用关系",
      "D)  组成关系"
    ],
    "a": "D"
  },
  {
    "q": " 在进行软件结构设计时应该遵循的最主要的原理是",
    "opts": [
      "A)  抽象",
      "B)  模块化",
      "C)  模块独立",
      "D)  信息隐蔽"
    ],
    "a": "C"
  },
  {
    "q": " 在测试中，下列说法错误的是",
    "opts": [
      "A)  测试是为了发现程序中的错误而执行程序的过程",
      "B)  测试是为了表明程序的正确性",
      "C)  好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案",
      "D)  成功的测试是发现了至今为止尚未发现的错误的测试"
    ],
    "a": "B"
  },
  {
    "q": " 下列工具中为需求分析常用工具是",
    "opts": [
      "A) PAD",
      "B)  PFD",
      "C)  N-S",
      "D) DFD"
    ],
    "a": "D"
  },
  {
    "q": " 软件调试的目的是",
    "opts": [
      "A)  发现错误",
      "B)  改正错误",
      "C)  改善软件的性能",
      "D)  挖掘软件的潜能"
    ],
    "a": "B"
  },
  {
    "q": " 软件详细设计主要采用的方法是  ",
    "opts": [
      "A)  结构化程序设计",
      "B)  模型设计",
      "C)  结构化设计",
      "D)  流程图设计"
    ],
    "a": "A"
  },
  {
    "q": " 软件开发的原型化方法是一种动态定义软件需求的方，下述条件中， 是实施原型化方法所必需的 Ⅰ 成熟的原型化人员\nⅡ 快速的成型工具\nⅢ 需求了解的正确性",
    "opts": [
      "A)  Ⅰ和Ⅱ",
      "B)  Ⅱ和Ⅲ",
      "C)  Ⅰ Ⅱ和Ⅲ",
      "D)  Ⅲ"
    ],
    "a": "A"
  },
  {
    "q": " 模块本身的内聚是模块独立性的重要性度量因素之一 在7类内聚中，具有最强内聚的一类是  ",
    "opts": [
      "A)  顺序性内聚",
      "B)  过程性内聚",
      "C)  逻辑性内聚",
      "D)  功能性内聚\n"
    ],
    "a": "D"
  },
  {
    "q": " 数据字典是对数据定义信息的集合，它所定义的对象都包含在 中 ",
    "opts": [
      "A)  数据流图",
      "B)  程序框图",
      "C)  软件结构",
      "D)  方框图"
    ],
    "a": "A"
  },
  {
    "q": " 软件开发的结构化分析方法，常用的描述软件功能需求的工具是  ",
    "opts": [
      "A)  业务流程图 处理说明",
      "B)  软件流程图 模块说明",
      "C)  数据流程图 数据字典",
      "D)  系统流程图 程序编码"
    ],
    "a": "C"
  },
  {
    "q": " 软件开发的结构化设计方法方法，全面指导模块化分的最重要的原则应该是  ",
    "opts": [
      "A)  模块高内聚",
      "B)  模块低耦合",
      "C)  模块独立性",
      "D)  程序模块化"
    ],
    "a": "D"
  },
  {
    "q": " 面向数据流的软件设计方法，一般是把数据流图中得数据流化分为 两种流，再将数据流图映射为软件结构 ",
    "opts": [
      "A)  数据流与事务流",
      "B)  交换流和事务流",
      "C)  信息流与控制流",
      "D)  交换流和数据流"
    ],
    "a": "B"
  },
  {
    "q": " 软件设计中，可应用于详细设计的工具有  ",
    "opts": [
      "A) nan",
      "B)  数据流程图 P",
      "C)  业务流程图 N-S图和伪码",
      "D)  N-S图和伪码"
    ],
    "a": "A"
  },
  {
    "q": " 软件开发的可行性研究，一般涉及经济 技术和操作的可能性，而进行可行性研究的基本依据则是用户提出的软件  ",
    "opts": [
      "A)  系统质量",
      "B)  系统目标",
      "C)  系统功能",
      "D)  系统性能"
    ],
    "a": "B"
  },
  {
    "q": " 结构化方法将软件生命周期分为计划 开发和运行3个时期，下列任务中 属于计划时期的任务 ",
    "opts": [
      "A)  需求分析",
      "B)  问题定义",
      "C)  总体设计",
      "D)  编码"
    ],
    "a": "B"
  },
  {
    "q": " 耦合是软件各个模块间连接的一种度量 一组模块都访问同一数据结构应属于 方式 ",
    "opts": [
      "A)  内容耦合",
      "B)  公共耦合",
      "C)  外部耦合",
      "D)  控制耦合"
    ],
    "a": "B"
  },
  {
    "q": " 内聚是从功能角度来度量模块内的联系，按照特定次序执行元素的模块属于 方式 ",
    "opts": [
      "A)  逻辑内聚",
      "B)  时间内聚",
      "C)  过程内聚",
      "D)  顺序内聚\n"
    ],
    "a": "C"
  },
  {
    "q": " 软件管理中，需要对软件进行配置，各阶段文档的管理属于  ",
    "opts": [
      "A)  组织管理",
      "B)  资源管理",
      "C)  计划管理",
      "D)  版本管理"
    ],
    "a": "D"
  },
  {
    "q": " 软件开发的结构化方法中，常用数据字典技术，其中数据加工是其组成内容之一，下述方法 是常采用编写加工说明的方法 Ⅰ 结构化语言\nⅡ 判定树\nⅢ 判定表",
    "opts": [
      "A)  Ⅰ",
      "B)  Ⅱ",
      "C)  Ⅱ Ⅲ",
      "D)  都是"
    ],
    "a": "D"
  },
  {
    "q": " 软件开发过程中，软件结构设计是描述  ",
    "opts": [
      "A)  数据存储结构",
      "B)  软件模块体系",
      "C)  软件结构测试",
      "D)  软件控制过程"
    ],
    "a": "B"
  },
  {
    "q": " ()是对象的静态特征 ",
    "opts": [
      "A)  方法",
      "B)  属性",
      "C)  关系",
      "D)  操作"
    ],
    "a": "B"
  },
  {
    "q": " 对象的 是对象的动态特征 ",
    "opts": [
      "A)  特征",
      "B)  属性",
      "C)  关系",
      "D)  操作"
    ],
    "a": "D"
  },
  {
    "q": " 属于某个类的一个具体对象称为该类的",
    "opts": [
      "A)  实例",
      "B)  虚拟",
      "C)  继承",
      "D)  多态"
    ],
    "a": "A"
  },
  {
    "q": " UML是 () ",
    "opts": [
      "A)   一种可视化的建模语言",
      "B)   是一种可视化的程序设计语言",
      "C)  是一种过程",
      "D)   是一种方法"
    ],
    "a": "A"
  },
  {
    "q": " 下列不属于面向对象分析模型的是",
    "opts": [
      "A)   用例图",
      "B)   类图",
      "C)   实体关系图",
      "D)   顺序图"
    ],
    "a": "C"
  },
  {
    "q": " 程序的三种基本控制结构是  ",
    "opts": [
      "A)  过程 子程序和分程序",
      "B)  顺序 选择和重复",
      "C)  递归 堆栈和队列",
      "D)  调用 返回和转移"
    ],
    "a": "B"
  },
  {
    "q": " 结构化程序设计主要强调的是  ",
    "opts": [
      "A)  程序的规模",
      "B)  程序的效率",
      "C)  程序设计语言的先进性",
      "D)  程序易读性"
    ],
    "a": "D"
  },
  {
    "q": " 使用白盒测试方法时，确定测试数据应根据 和指定的覆盖标准 ",
    "opts": [
      "A)  程序内部逻辑",
      "B)  程序复杂结构",
      "C)  使用说明书",
      "D)  程序的功能"
    ],
    "a": "A"
  },
  {
    "q": " 确认测试主要涉及的文档是  ",
    "opts": [
      "A)  需求规格说明书",
      "B)  概要设计说明书",
      "C)  详细设计说明书",
      "D)  源程序"
    ],
    "a": "A"
  },
  {
    "q": " 测试的关键问题是  ",
    "opts": [
      "A)  如何组织对软件的评审",
      "B)  如何验证程序的正确性",
      "C)  如何采用综合策略",
      "D)  如何选择测试用例"
    ],
    "a": "D"
  },
  {
    "q": " 下面哪个测试属于黑盒测试  ",
    "opts": [
      "A)  路径测试",
      "B)  等价类划分",
      "C)  条件判断覆盖测试",
      "D)  循环测试"
    ],
    "a": "B"
  },
  {
    "q": " 软件测试方法中，黑盒 白盒测试法是常用的方法，其中白盒测试主要用于测试  ",
    "opts": [
      "A)   结构合理性",
      "B)  软件外部功能",
      "C)  程序正确性",
      "D)  程序内部逻辑"
    ],
    "a": "D"
  },
  {
    "q": " 为了适应软硬件环境变化而修改软件的过程是  ",
    "opts": [
      "A)  校正性维护",
      "B)  完善性维护",
      "C)  适应性维护",
      "D)  预防性维护"
    ],
    "a": "C"
  },
  {
    "q": " 在McCall软件质量度量模型中， 属于面向软件产品修改的是",
    "opts": [
      "A)  可靠性",
      "B)  可重用性",
      "C)  适应性",
      "D)  可移植性"
    ],
    "a": "C"
  },
  {
    "q": " 瀑布模型的存在问题是",
    "opts": [
      "A)  用户容易参与开发",
      "B)  缺乏灵活性",
      "C)  用户与开发者易沟通",
      "D)  适用可变需求"
    ],
    "a": "B"
  },
  {
    "q": " 软件生命周期中所花费用最多的阶段是",
    "opts": [
      "A)  详细设计",
      "B)  软件编码",
      "C)  软件测试",
      "D)  软件维护"
    ],
    "a": "D"
  },
  {
    "q": " 程序的三种基本控制结构的共同特点是",
    "opts": [
      "A)  不能嵌套使用",
      "B)  只能用来写简单程序",
      "C)  已经用硬件实现",
      "D)  只有一个入口和一个出口"
    ],
    "a": "D"
  },
  {
    "q": " 原型化方法是用户和设计者之间执行的一种交互构成，适用于 系统 ",
    "opts": [
      "A)  需求不确定性高的",
      "B)  需求确定的",
      "C)  管理信息",
      "D)  实时"
    ],
    "a": "A"
  },
  {
    "q": " 以下不属于逻辑覆盖的是  ",
    "opts": [
      "A)   语句覆盖",
      "B)   判定覆盖",
      "C)   条件覆盖",
      "D)   基本路径覆盖"
    ],
    "a": "D"
  },
  {
    "q": " 一个模块的 是指能直接控制该模块的模块数 ",
    "opts": [
      "A)   扇出数",
      "B)   扇入数",
      "C)   宽度",
      "D)   深度"
    ],
    "a": "B"
  },
  {
    "q": " 软件需求分析阶段的工作，可以分为4个方面：需求获取，需求分析，编写需求规格说明书以及  ",
    "opts": [
      "A)  用户",
      "B)  需求审评",
      "C)  总结",
      "D)  都不正确"
    ],
    "a": "B"
  },
  {
    "q": " 以下分析模型的结构成员中，属于行为模型的是  ",
    "opts": [
      "A)   数据流图",
      "B)   实体-关系图",
      "C)   状态转换图",
      "D)   数据字典"
    ],
    "a": "C"
  },
  {
    "q": " 在白盒法技术测试用例的设计中 是最弱的覆盖标准 ",
    "opts": [
      "A)   语句",
      "B)   条件",
      "C)   判定",
      "D)   条件组合"
    ],
    "a": "A"
  },
  {
    "q": " 模块化中的信息隐藏原则是指  ",
    "opts": [
      "A)   使信息对用户隐藏",
      "B)   使信息对其它模块隐藏",
      "C)   使信息对软件隐藏",
      "D)   使信息对操作系统隐藏"
    ],
    "a": "B"
  },
  {
    "q": " CASE是指  ",
    "opts": [
      "A)  计算机辅助软件开发",
      "B)  计算机辅助软件制造",
      "C)  计算机辅助软件工程",
      "D)  计算机辅助软件设计"
    ],
    "a": "C"
  },
  {
    "q": " 以下软件生命周期模型中， ()是用户驱动的模型 ",
    "opts": [
      "A)  快速原型模型",
      "B)  螺旋模型",
      "C)  喷泉模型",
      "D)  瀑布模型"
    ],
    "a": "A"
  },
  {
    "q": " 若有一个计算类型的程序，它的输入量只有一个X，其范围是［-1 0，1 0］，现从输入的角度考虑一组测试用例：-1 001，-1 0，1 0，1 001。设计这组测试用例的方法是   ",
    "opts": [
      "A)  条件覆盖法",
      "B)  等价分类法",
      "C)  边界值分析法",
      "D)  错误推测法"
    ],
    "a": "A"
  },
  {
    "q": " 模块的扇入是指  ",
    "opts": [
      "A)  本模块的所有上层模块数",
      "B)  本模块的所有下层模块数",
      "C)  调用本模块的所有模块数",
      "D)  本模块调用的所有模块数"
    ],
    "a": "A"
  },
  {
    "q": " 软件生存周期是指  ",
    "opts": [
      "A)  开发软件的全部时间",
      "B)  使用软件的全部时间",
      "C)  开发和使用软件的全部时间",
      "D)  从软件计划起直到软件废弃所经历的全部时间"
    ],
    "a": "D"
  },
  {
    "q": " 测试用例是指  ",
    "opts": [
      "A)  被测对象",
      "B)  测试的输入数据",
      "C)  测试数据+预期结果",
      "D)  测试的预期结果"
    ],
    "a": "C"
  },
  {
    "q": "软件能力成熟度模型CMM分为 个等级 ",
    "opts": [
      "A) 3",
      "B) 4",
      "C) 5",
      "D) 6"
    ],
    "a": "C"
  },
  {
    "q": "数据流A由若干个数据项B和一个数据项C组成，用数据字典的符号表示出来 ",
    "opts": [
      "A) A = { B + C}",
      "B) A = {B}+{C}",
      "C) A = B+{C}",
      "D)  A = {B} + C"
    ],
    "a": "A"
  },
  {
    "q": " 分层中父子平衡是指  ",
    "opts": [
      "A)  父加工的数据流数目与子图中数据流数目相同",
      "B)  父图应包含子图中的全部数据流",
      "C)  子图应包含父图中的全部数据流",
      "D)  父加工和子图的输入数据和输出数据应分别保持一致"
    ],
    "a": "D"
  },
  {
    "q": " 下列 属于不良的编程习惯 ",
    "opts": [
      "A)  尽量不使用GOTO语句",
      "B)  从来不使用注释",
      "C)  每行只写一条语句",
      "D)  变量命名尽量直观"
    ],
    "a": "B"
  },
  {
    "q": " 瀑布模型中各阶段按时间先后顺序是  ",
    "opts": [
      "A)  计划→需求分析→编码→设计→测试→维护",
      "B)  计划→需求分析→设计→编码→测试→维护",
      "C)  计划→设计→需求分析→编码→测试→维护",
      "D)  计划→需求分析→设计→测试→编码→维护"
    ],
    "a": "B"
  },
  {
    "q": " 目前最流行的面向对象建模语言是  ",
    "opts": [
      "A)  HTML",
      "B)  XML",
      "C)  UML",
      "D)  VML"
    ],
    "a": "C"
  }
];

let currentSet = [];
  const quizEl = document.getElementById('quiz');
  const submitBtn = document.getElementById('submitBtn');
  const resetBtn = document.getElementById('resetBtn');
  const resultDiv = document.getElementById('result');

  // 随机抽取 n 题
  function sampleQuestions(n) {
    const arr = questionBank.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, n);
  }

  // 渲染题目
  function renderQuiz() {
    quizEl.querySelectorAll('.question').forEach(el => el.remove());
    resultDiv.textContent = '';
    submitBtn.disabled = true;
    currentSet = sampleQuestions(5);
    currentSet.forEach((item, idx) => {
      const div = document.createElement('div');
      div.className = 'question';
      div.dataset.answer = item.a;
      div.innerHTML = `
        <h2>${idx + 1}．${item.q}</h2>
        <div class="options">
          ${item.opts.map((opt, i) =>
            `<label><input type="radio" name="q${idx}" value="${opt.charAt(0)}"> ${opt}</label>`
          ).join('')}
        </div>
        <div class="correct-answer" style="display: none; color: green; font-weight: bold;">
          正确答案：${item.a}
        </div>`;
      quizEl.insertBefore(div, submitBtn);
      // 选项变化监听
      div.querySelectorAll('input').forEach(r => {
        r.addEventListener('change', () => {
          const allAnswered = currentSet.every((_, i) =>
            !!quizEl.querySelector(`input[name="q${i}"]:checked`)
          );
          submitBtn.disabled = !allAnswered;
        });
      });
    });
  }

  // 计算并显示结果
  submitBtn.addEventListener('click', () => {
    let correct = 0;
    currentSet.forEach((_, idx) => {
      const sel = quizEl.querySelector(`input[name="q${idx}"]:checked`).value;
      const questionDiv = quizEl.querySelector(`.question:nth-child(${idx + 1})`);
      const correctAnswerDiv = questionDiv.querySelector('.correct-answer');
      correctAnswerDiv.style.display = 'block'; // 显示正确答案
      if (sel === currentSet[idx].a) correct++;
    });
    resultDiv.textContent = `您答对了 ${correct} / ${currentSet.length} 题`;
    submitBtn.disabled = true;
  });

  // 再来一套
  resetBtn.addEventListener('click', renderQuiz);

  // 首次加载
  renderQuiz();
</script>

</body>
</html>
